package rdb

import (
	"bufio"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
	"time"
)

const EmptyHexDatabase = "524544495330303131fa0972656469732d76657205372e322e30fa0a72656469732d62697473c040fa056374696d65c26d08bc65fa08757365642d6d656dc2b0c41000fa08616f662d62617365c000fff06e3bfec0ff5aa2"

type ValueEntry struct {
	Key    string
	Value  interface{}
	Type   int
	Expiry *time.Time
}

const (
	TString = iota
	TSet    = iota
	TStream = iota
)

func TypeToString(t int) string {
	switch t {
	case TString:
		return "string"
	case TSet:
		return "set"
	case TStream:
		return "stream"
	default:
		return "unknown"
	}
}

type Stream struct {
	Entries []*StreamEntry
}

type StreamEntry struct {
	Id         EntryId
	Properties []StreamEntryProperty
}

type StreamEntryProperty struct {
	Key   string
	Value string
}

type EntryId struct {
	MilliTime      int
	SequenceNumber int
}

func EntryIdFromString(s string, stream *Stream) (*EntryId, error) {
	// Handle happy path of fully autogenerated
	if s == "*" {
		milli := int(time.Now().UnixMilli())
		var seq = 0

		if len(stream.Entries) > 0 {
			lastId := stream.Entries[len(stream.Entries)-1].Id

			if lastId.MilliTime == milli {
				seq = lastId.SequenceNumber + 1
			}
		}

		entry := EntryId{
			MilliTime:      milli,
			SequenceNumber: seq,
		}
		return &entry, nil
	}

	// Otherwise parse out the parts
	parts := strings.Split(s, "-")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid entry ID format")
	}

	milli, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil, fmt.Errorf("invalid millisecond time: %v", err)
	}

	// Parse the sequence number, or auto generate from the existing stream.
	var seq = 0
	if parts[1] == "*" {
		if len(stream.Entries) > 0 {
			lastId := stream.Entries[len(stream.Entries)-1].Id

			if lastId.MilliTime == milli {
				seq = lastId.SequenceNumber + 1
			}
		} else {
			if milli == 0 {
				seq = 1
			}
		}
	} else {
		seq, err = strconv.Atoi(parts[1])
		if err != nil {
			return nil, fmt.Errorf("invalid sequence number: %v", err)
		}
	}

	entry := EntryId{
		MilliTime:      milli,
		SequenceNumber: seq,
	}
	return &entry, nil
}

func (e EntryId) String() string {
	return fmt.Sprintf("%d-%d", e.MilliTime, e.SequenceNumber)
}

func (e EntryId) ValidateAgainstStream(s *Stream) error {
	if e.MilliTime == 0 && e.SequenceNumber == 0 {
		return errors.New("ERR The ID specified in XADD must be greater than 0-0")
	}

	if len(s.Entries) > 0 {
		lastId := s.Entries[len(s.Entries)-1].Id

		if e.MilliTime < lastId.MilliTime || (e.MilliTime == lastId.MilliTime && e.SequenceNumber <= lastId.SequenceNumber) {
			return errors.New("ERR The ID specified in XADD is equal or smaller than the target stream top item")
		}
	}

	return nil
}

func readHeader(reader *bufio.Reader) (int, error) {
	buffer := make([]byte, 9)

	_, err := io.ReadFull(reader, buffer)

	if err != nil {
		return -1, errors.New("error reading file header")
	}

	headerString := string(buffer)
	if !strings.HasPrefix(headerString, "REDIS") {
		return -1, errors.New("file header does not contain expected REDIS")
	}

	versionNumber, err := strconv.Atoi(headerString[5:])
	if err != nil {
		return -1, errors.New("error decoding file version number")
	}

	return versionNumber, nil
}

func readString(reader *bufio.Reader) (string, error) {
	strLen, isString, err := readSize(reader)
	if err != nil {
		return "", err
	}

	if isString {
		return strconv.Itoa(strLen), nil
	} else {
		strBuffer := make([]byte, strLen)
		io.ReadFull(reader, strBuffer)
		return string(strBuffer), nil
	}
}

func readMetadata(reader *bufio.Reader) (map[string]string, error) {
	metadata := map[string]string{}

	peeked, err := reader.Peek(1)
	if err != nil {
		return metadata, errors.New("couldn't peek metadata")
	}
	if peeked[0] != 0xFA {
		return metadata, errors.New("expected 0xFA marker byte as metadata header section")
	}
	reader.Discard(1)

	for peeked[0] != 0xFE {
		peeked, err = reader.Peek(1)
		if err != nil {
			return metadata, errors.New("couldn't peek reader")
		}

		if peeked[0] >= 0xFE {
			break
		} else if peeked[0] == 0xFA {
			reader.Discard(1)
		}

		name, err := readString(reader)
		if err != nil {
			return metadata, err
		}
		value, err := readString(reader)
		if err != nil {
			return metadata, err
		}

		metadata[name] = value
	}

	return metadata, nil
}

// Read a size value. Boolean flag indicates whether to treat the return as the full string.
func readSize(reader *bufio.Reader) (int, bool, error) {
	headerByte, _ := reader.ReadByte()

	switch (headerByte & 0b11000000) >> 6 {
	case 0:
		// Lower 6 bits are the number encoded
		return int(headerByte), false, nil
	case 1:
		// Lower 6 bits combined with the next 8 bits (big-endian) encode a 14bit number
		nextByte, _ := reader.ReadByte()
		return int(headerByte&0b00111111)<<8 | int(nextByte), false, nil
	case 2:
		// Header byte is discarded, just read next 4 bytes as a big-endian value.
		intval := uint32(0)
		binary.Read(reader, binary.BigEndian, &intval)
		return int(intval), false, nil
	case 3:
		// String endoded values
		switch headerByte {
		case 0xC0:
			v := uint8(0)
			binary.Read(reader, binary.LittleEndian, &v)
			return int(v), true, nil
		case 0xC1:
			v := uint16(0)
			binary.Read(reader, binary.LittleEndian, &v)
			return int(v), true, nil
		case 0xC2:
			v := uint32(0)
			binary.Read(reader, binary.LittleEndian, &v)
			return int(v), true, nil
		case 0xC3:
			return -1, false, errors.New("RDB LZF string encoded values NYI")
		default:
			return -1, false, fmt.Errorf("invalid string encoded value %x", headerByte)
		}
	default:
		panic("readSize unreachable branch")
	}
}

func readDatabase(reader *bufio.Reader) (map[string]*ValueEntry, error) {
	hashtable := map[string]*ValueEntry{}

	b, err := reader.ReadByte()
	if err != nil || b < 0xFE {
		return hashtable, errors.New("expected 0xFE marker byte as database section marker")
	} else if b == 0xFF {
		// Empty database with no database section
		return hashtable, nil
	}

	readSize(reader) // Skip databaseIndex

	b, err = reader.ReadByte()
	if err != nil || b != 0xFB {
		return hashtable, errors.New("expected 0xFB marker byte as hashtable marker")
	}

	tableSize, _, err := readSize(reader)
	if err != nil {
		return hashtable, errors.New("expected table size")
	}
	readSize(reader) // Skip expiringKeySize

	hashtable = make(map[string]*ValueEntry, tableSize)

	for {
		b, _ = reader.ReadByte()

		switch b {

		case 0xFF:
			// End of file section marker
			return hashtable, nil

		case 0xFC:
			// Millisecond expiring key
			timestamp := uint64(0)
			binary.Read(reader, binary.LittleEndian, &timestamp)
			expiry := time.UnixMilli(int64(timestamp))

			// TODO: Handle other types
			b, _ = reader.ReadByte()
			if b != 0x00 {
				panic("Expected string to follow expiration")
			}

			name, err := readString(reader)
			if err != nil {
				return hashtable, err
			}
			value, err := readString(reader)
			if err != nil {
				return hashtable, err
			}

			// Skip loading expired values
			if expiry.Before(time.Now()) {
				continue
			}

			hashtable[name] = &ValueEntry{
				Key:    name,
				Value:  value,
				Expiry: &expiry,
			}

		case 0xFD:
			// Second expiring key
			timestamp := uint32(0)
			binary.Read(reader, binary.LittleEndian, &timestamp)
			expiry := time.Unix(int64(timestamp), 0)

			// TODO: Handle other types
			b, _ = reader.ReadByte()
			if b != 0x00 {
				panic("Expected string to follow expiration")
			}

			name, err := readString(reader)
			if err != nil {
				return hashtable, err
			}
			value, err := readString(reader)
			if err != nil {
				return hashtable, err
			}

			// Skip loading expired values
			if expiry.Before(time.Now()) {
				continue
			}

			hashtable[name] = &ValueEntry{
				Key:    name,
				Value:  value,
				Expiry: &expiry,
			}

		case 0x00:
			// String entry
			name, err := readString(reader)
			if err != nil {
				return hashtable, err
			}
			value, err := readString(reader)
			if err != nil {
				return hashtable, err
			}

			hashtable[name] = &ValueEntry{
				Key:    name,
				Value:  value,
				Type:   TString,
				Expiry: nil,
			}
		}
	}
}

type LoadedDatabase struct {
	Version   int
	Metadata  map[string]string
	Hashtable map[string]*ValueEntry
}

func LoadDatabase(path string) (*LoadedDatabase, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	return LoadDatabaseFromReader(file)
}

func LoadDatabaseFromReader(reader io.Reader) (*LoadedDatabase, error) {
	bufReader := bufio.NewReader(reader)

	version, err := readHeader(bufReader)
	if err != nil {
		return nil, err
	}
	metadata, err := readMetadata(bufReader)
	if err != nil {
		return nil, err
	}
	hashtable, err := readDatabase(bufReader)
	if err != nil {
		return nil, err
	}

	return &LoadedDatabase{
		Version:   version,
		Metadata:  metadata,
		Hashtable: hashtable,
	}, nil
}
